1.求命题关系的主范式
1.1概述
实现功能：输入命题公式的合式公式，求出公式的真值表，并输出该公式的主合取范式和主析取范式。
输入：命题公式的合式公式
输出：公式的主析取范式和主析取范式，输出形式为：“ mi ∨ mj ; Mi ∧ Mj” ，极小项和 ∨ 符号之间有一个空格，极大项和 ∧ 符号之间有一个空格；主析取范式和主合取范式之间用“ ; ”隔开，“ ; ”前后各有一个空格。 永真式的主合取范式为 1 ，永假式的主析取范式为 0 。
输入公式的符号说明：
! 非，相当于书面符号中的 “ ¬ ”
& 与，相当于书面符号中的 “ ∧ ”
| 或，相当于书面符号中的 “ ∨ ”
- 蕴含联结词，相当于书面符号中的 “ → ”
+ 等价联结词，相当于书面符号中的 “ ↔ ”
( 前括号
) 后括号
1.2步骤流程
在运算优先级中
( < - = + < & < | < ! < )
先设定运算优先级
然后读入数据，入栈，根据运算符优先级进队列
求出输入的表达式的后缀表达式
再将后缀表达式转化成二叉树
再根据二叉树，类似图的深度优先搜索算法，计算真值表
最后输出结果
1.3程序实现
1.3.1
函数cal：
用于根据二叉树目前读到的节点的symbol和左子树右子树进行运算，用到了递归过程。
如果左子树=右子树，那么根的值就是命题变元的值
如果根的左子树不是空，那么进入下一层，计算根的左子树
如果根的右子树不是空，那么进入下一层，计算根的右子树
判断根对应的代数符号（否定，析取，合取，蕴含，等价），并且进行运算。
1.3.2
函数newnode：
构建一个新节点，并且初始化，用于程序中二叉树的构建。
实际上，在这里newnode应该使用面向对象的方法，创建类，更方便创建新的对象，节约代码量。
